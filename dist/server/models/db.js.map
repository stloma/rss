{"version":3,"sources":["../../../src/server/models/db.js"],"names":["MongoDBStore","store","uri","collection","on","error","rssDb","connect","then","connection","catch","console","log","getFeeds","userDb","cb","movies","html","finalResult","findOne","slug","_id","data","insert","categories","favorites","favoritesLookup","read","metadata","updated","Date","ids","id","push","categoryIds","map","find","$in","toArray","feeds","refreshArticles","category","name","url","currentTime","update","$set","result","fetchPromise","Promise","resolve","reject","articles","feedData","items","article","rssCategory","rssFeed","bookmark","newBookmark","feed","title","action","$push","$pull","getCategories","addFeed","addCategory","reference","err","deleteCategory","dbname","toDelete","query","$unset"],"mappings":"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","file":"db.js","sourcesContent":["import session from 'express-session'\nimport { MongoClient, ObjectId } from 'mongodb'\nimport connectMongo from 'connect-mongodb-session'\nimport { fetchFeeds } from '../scripts/get.js'\n\nconst MongoDBStore = connectMongo(session)\n\nconst store = new MongoDBStore(\n  {\n    uri: 'mongodb://localhost/rssapp',\n    collection: 'sessions'\n  })\n\nstore.on('error', function (error) {\n  if (error) throw error\n})\n\nlet rssDb\n\nMongoClient.connect('mongodb://localhost/rssapp')\n  .then(connection => {\n    rssDb = connection\n  })\n  .catch(error => {\n    console.log(`Error connection to db: ${error}`)\n  })\n\nfunction getFeeds (userDb, cb) {\n\n  let movies = async() => {\n    let html = 'html'\n    console.log(html)\n  }\n  console.log(movies)\n\n  let finalResult = ''\n  rssDb.collection(userDb).findOne({ slug: 'data' }, { _id: 0, slug: 0 })\n    // Get main data document; create it if it doesn't exist\n    .then(data => {\n      if (data !== null) {\n        return data\n      } else {\n        rssDb.collection(userDb).insert({\n          slug: 'data',\n          categories: {},\n          favorites: [],\n          favoritesLookup: {},\n          read: {},\n          metadata: { updated: new Date() }\n        })\n        .then(getFeeds(userDb, cb))\n        .catch(error => console.log(`Error creating database: ${error}`))\n      }\n    })\n    // Get category documents\n    .then(data => {\n      finalResult = data\n      const ids = []\n      const categories = data.categories\n      for (let id in categories) {\n        ids.push(categories[id])\n      }\n      let categoryIds = ids.map(id => ObjectId(id))\n      return rssDb.collection(userDb).find({ _id: { $in: categoryIds } }, { _id: 0 }).toArray()\n    })\n    // Add category documents to main data document and return\n    .then(feeds => {\n      finalResult.feeds = feeds\n      cb(null, { data: finalResult })\n    })\n}\n\nfunction refreshArticles (userDb, category, name, url, cb) {\n  const currentTime = new Date()\n  rssDb.collection(userDb).update({ slug: 'data' }, {$set: { 'metadata.updated': currentTime }})\n    .catch(error => console.log(`Error updating time: ${error}`))\n\n  let _id = ''\n  rssDb.collection(userDb).findOne({ slug: 'data' }, { _id: 0, slug: 0 })\n    .then(result => result.categories[category])\n    .then(id => { _id = new ObjectId(id) })\n    .catch(error => console.log(`Error getting id for ${name}: ${error}`))\n\n  let fetchPromise = new Promise((resolve, reject) => {\n    fetchFeeds(url, function (error, result) {\n      if (error) reject(error)\n      resolve(result)\n    })\n  })\n\n  fetchPromise\n    .then(feedData => {\n      let articles = feedData.items\n      delete feedData.items\n      articles = articles.map(article => {\n        article.rssCategory = category\n        article.rssFeed = name\n        article.bookmark = article.bookmark || false\n        return article\n      })\n      rssDb.collection(userDb).update({ _id: _id }, { $set: { [`${name}.metadata`]: feedData } })\n        .catch(error => console.log(`Error updating ${name} metadata: ${error}`))\n      rssDb.collection(userDb).update({ _id: _id }, { $set: { [`${name}.articles`]: articles } })\n        .catch(error => console.log(`Error updating ${name} articles: ${error}`))\n    })\n\n    // Sets up some query/filter strings\n    //\n      /*\n    const category = dir + '.name'\n    const filter = {\n      _id: _id\n    }\n    filter[category] = name\n\n    const projection = dir + '.$.'\n\n    const updated = projection + 'updated'\n    const title = projection + 'title'\n    const description = projection + 'description'\n    const articles = projection + 'articles'\n    const count = projection + 'count'\n\n    // Start article cleanup\n    //\n    let newArticles = result.items\n    let oldArticles = []\n\n    // Pull & delete articles\n    let clearArticles = {}\n    clearArticles[articles] = []\n\n    function cleanUp (cb) {\n      rssDb.collection('feeds').findAndModify(\n            filter,\n            [['_id', 'asc']],\n            {$set: clearArticles},\n             function (err, result) {\n               if (err) throw err\n               // Is this having to filter *all* articles based on name each time?\n               //\n               result.value[dir].map(item => console.log(item.name))\n               cb(null, result.value[dir].filter(item => item.name === name)[0].articles)\n             }\n          )\n    }\n    cleanUp(function (err, res) {\n      if (err) throw err\n\n      oldArticles = res\n      let mergedArticles = [...newArticles, ...oldArticles]\n      // Sort articles by date\n      //\n      mergedArticles.sort(function (a, b) {\n        b.directory = dir\n        a.directory = dir\n        b.feed = name\n        a.feed = name\n        return new Date(b.pubdate).getTime() - new Date(a.pubdate).getTime()\n      })\n      // Remove duplicate articles\n      //\n      let seen = {}\n      let dupFreeArticles = []\n      for (let i = 0; i < mergedArticles.length; i++) {\n        let title = mergedArticles[i].title\n        if (seen[title]) {\n          continue\n        }\n        seen[title] = true\n        dupFreeArticles.push(mergedArticles[i])\n      }\n\n      // Updates feed metadata (title, description, updated time, count)\n      //\n      let feedQuery = {}\n      feedQuery[title] = result.title\n      feedQuery[description] = result.description\n      feedQuery[updated] = currentTime\n      feedQuery[count] = dupFreeArticles.length\n\n      rssDb.collection('feeds').update(filter, {\n        $set: feedQuery\n      }, function (error, result) {\n        if (error) {\n          cb(error)\n        }\n      })\n\n      // Insert merged & sorted articles\n      let articleQuery = {}\n      articleQuery[articles] = {}\n      let each = '$each'\n      articleQuery[articles][each] = dupFreeArticles\n\n      rssDb.collection('feeds').update(filter, {\n        $push: articleQuery\n      }, function (error, result) {\n        if (error) {\n          cb(error)\n        }\n      })\n    })\n  })\n    */\n}\n\nfunction bookmark (userDb, newBookmark, cb) {\n  const category = newBookmark.rssCategory\n  const feed = newBookmark.rssFeed\n  const title = newBookmark.title\n  const bookmark = !newBookmark.bookmark\n  newBookmark.bookmark = bookmark\n\n  rssDb.collection(userDb).findOne({ slug: 'data' }, { _id: 0, [`categories.${category}`]: 1 })\n  .then(result => {\n    const _id = result.categories[category]\n\n    const action = bookmark === true ? 'add' : 'remove'\n    return rssDb.collection(userDb).update(\n      { _id: ObjectId(_id), [`${feed}.articles.title`]: title },\n      { '$set': { [`${feed}.articles.$.bookmark`]: bookmark } }\n    ).then(() => { return action })\n  })\n  .then(action => {\n    if (action === 'add') {\n      return rssDb.collection(userDb).update(\n        { slug: 'data' },\n        { $push: { favorites: newBookmark } }\n      )\n    } else if (action === 'remove') {\n      return rssDb.collection(userDb).update(\n        { slug: 'data' },\n        { $pull: { favorites: { title: title } } }\n      )\n    }\n  })\n  .then(() => cb(null, 'success'))\n  .catch(error => cb(error))\n}\n\nfunction getCategories (cb) {\n  rssDb.collection('categories').find().toArray()\n    .then(categories => {\n      cb(null, { categories: categories })\n    })\n}\n\nfunction addFeed (userDb, feed, cb) {\n  const { category, name, url } = feed\n  // let feedName = name\n  let update = { [`categories.${category}`]: 1 }\n\n  rssDb.collection(userDb).findOne({ slug: 'data' }, update)\n    .then(result => {\n      rssDb.collection(userDb).update(\n      { _id: result.categories[category] },\n      { $set: { [name]: { articles: [], url: url, category: category, updated: new Date() } } }\n    )\n    })\n    .catch(error => console.log(error))\n}\n\nfunction addCategory (userDb, category, _id, cb) {\n  const reference = new ObjectId()\n\n  let addCategory = { [`categories.${category}`]: reference }\n\n  rssDb.collection(userDb).insert({ _id: reference, name: category })\n\n  rssDb.collection(userDb).update({ slug: 'data' }, {\n    $set: addCategory\n  },\n   function (err, result) {\n     if (err) {\n       cb(err)\n     } else {\n       cb(null, result)\n     }\n   }\n  )\n}\n\nfunction deleteCategory (dbname, toDelete, _id, cb) {\n  const id = new ObjectId(_id)\n\n  for (let category in toDelete) {\n    let query = {}\n    query[toDelete[category]] = ''\n    rssDb.collection('feeds').update({ _id: id }, {\n      $unset: query\n    },\n   function (err, result) {\n     if (err) {\n       cb(err)\n     } else {\n       cb(null, result)\n     }\n   }\n  )\n  }\n}\n  /*\nfunction fetchArticles (directories, cb) {\n  directories.map(dir =>\n    dir.items.map(item =>\n      downloadFeed(item.url, function (error, result) {\n        if (error) throw error\n        console.log(result.title)\n        console.log(result.description)\n      })\n    )\n  )\n  // let bookmarkId = new ObjectId(site._id)\n  rssDb.collection('directories').update({ title: feed.category }, {\n    $push: {\n      items: {\n        name: feed.name,\n        url: feed.url\n      }\n    }\n  }, function (error, result) {\n    if (error) {\n      cb(error)\n    } else {\n      cb(null, result)\n    }\n  })\n}\n  */\n\n  /*\nfunction addSite (rssDb, newFeed, cb) {\n  let feedId = new ObjectId(newFeed._id)\n  bookmarkDb.collection(bmarkDb).updateOne({ _id: bookmarkId }, {\n    $set: {\n      name: site.name,\n      url: site.url,\n      comment: site.comment,\n      tags: site.tags,\n      update: site.updated\n    }}, function (error, result) {\n      if (error) {\n        cb(error)\n      } else {\n        cb(null, result)\n      }\n    })\n}\n\nfunction addFeed (bmarkDb, newFeed, cb) {\n  rssDb.collection(bmarkDb).insertOne(newFeed, function (error, res) {\n    let _id = res.insertedId\n\n    download(newSite.url, _id, function (error, result) {\n      if (error) {\n        cb(error)\n        return\n      }\n      newSite.favicon = result ? _id + '.ico' : 'default-favicon.png'\n      let bookmarkId = new ObjectId(_id)\n      bookmarkDb.collection(bmarkDb).updateOne({ _id: bookmarkId },\n        {$set: {\n          favicon: newSite.favicon\n        }})\n          .catch(error => {\n            throw error\n          })\n    })\n    cb(error, res)\n  })\n}\n*/\n\n/*\nfunction getFeeds (userDb, cb) {\n  rssDb.collection('bookmarks.' + userDb).find().toArray()\n    .then(bookmarks => {\n      let result = countBy(bookmarks.map(function (bookmark) {\n        return bookmark.tags\n      })\n         .join(' ')\n        .split(' ')\n      )\n      let tagcount = []\n      Object.keys(result).forEach((tag) => {\n        tagcount.push({ value: tag, count: result[tag] })\n      })\n      const metadata = { total_count: bookmarks.length }\n      cb(null, { _metadata: metadata, tagcount: tagcount, records: bookmarks })\n    })\n    .catch(error => {\n      cb(error)\n    })\n}\n*/\n\n  /*\n\nfunction deleteSite (bmarkDb, _id, cb) {\n  bookmarkDb.collection(bmarkDb).deleteOne({ _id: _id }).then((result) => {\n    let error = result.result.n === 1 ? null : '404'\n    cb(error)\n  })\n  .catch(error => {\n    cb(error)\n  })\n}\n\n*/\n\nexport { bookmark, rssDb, store, getFeeds, getCategories, refreshArticles, addFeed, addCategory, deleteCategory }\n"]}